<?php

declare(strict_types=1);

/**
 * This file is automatic generated by build_docs.php file
 * and is used only for autocomplete in multiple IDE
 * don't modify manually.
 */

namespace danog\MadelineProto\TON;

use Amp\Future;
use danog\MadelineProto\Logger;
use danog\MadelineProto\StrTools;
use danog\MadelineProto\TL\Conversion\Extension;
use danog\MadelineProto\Tools;
use Generator;
use Throwable;
use TypeError;

interface liteServer
{
    /**
     * @return liteServer.MasterchainInfo
     */
    public function getMasterchainInfo(): liteServer;

    /**
     * Parameters:
     * * `#` **mode** -.
     *
     * @param array $params Parameters
     * @return liteServer.MasterchainInfoExt
     */
    public function getMasterchainInfoExt(array $params): liteServer;

    /**
     * @return liteServer.CurrentTime
     */
    public function getTime(): liteServer;

    /**
     * @return liteServer.Version
     */
    public function getVersion(): liteServer;

    /**
     * Parameters:
     * * `tonNode.blockIdExt` **id** -.
     *
     * @param array $params Parameters
     * @return liteServer.BlockData
     */
    public function getBlock(array $params): liteServer;

    /**
     * Parameters:
     * * `tonNode.blockIdExt` **id** -.
     *
     * @param array $params Parameters
     * @return liteServer.BlockState
     */
    public function getState(array $params): liteServer;

    /**
     * Parameters:
     * * `tonNode.blockIdExt` **id**   -
     * * `#`                  **mode** -.
     *
     * @param array $params Parameters
     * @return liteServer.BlockHeader
     */
    public function getBlockHeader(array $params): liteServer;

    /**
     * Parameters:
     * * `bytes` **body** -.
     *
     * @param array $params Parameters
     * @return liteServer.SendMsgStatus
     */
    public function sendMessage(array $params): liteServer;

    /**
     * Parameters:
     * * `tonNode.blockIdExt`   **id**      -
     * * `liteServer.accountId` **account** -.
     *
     * @param array $params Parameters
     * @return liteServer.AccountState
     */
    public function getAccountState(array $params): liteServer;

    /**
     * Parameters:
     * * `#`                    **mode**      -
     * * `tonNode.blockIdExt`   **id**        -
     * * `liteServer.accountId` **account**   -
     * * `long`                 **method_id** -
     * * `bytes`                **params**    -.
     *
     * @param array $params Parameters
     * @return liteServer.RunMethodResult
     */
    public function runSmcMethod(array $params): liteServer;

    /**
     * Parameters:
     * * `tonNode.blockIdExt` **id**        -
     * * `int`                **workchain** -
     * * `long`               **shard**     -
     * * `Bool`               **exact**     -.
     *
     * @param array $params Parameters
     * @return liteServer.ShardInfo
     */
    public function getShardInfo(array $params): liteServer;

    /**
     * Parameters:
     * * `tonNode.blockIdExt` **id** -.
     *
     * @param array $params Parameters
     * @return liteServer.AllShardsInfo
     */
    public function getAllShardsInfo(array $params): liteServer;

    /**
     * Parameters:
     * * `tonNode.blockIdExt`   **id**      -
     * * `liteServer.accountId` **account** -
     * * `long`                 **lt**      -.
     *
     * @param array $params Parameters
     * @return liteServer.TransactionInfo
     */
    public function getOneTransaction(array $params): liteServer;

    /**
     * Parameters:
     * * `#`                    **count**   -
     * * `liteServer.accountId` **account** -
     * * `long`                 **lt**      -
     * * `int256`               **hash**    -.
     *
     * @param array $params Parameters
     * @return liteServer.TransactionList
     */
    public function getTransactions(array $params): liteServer;

    /**
     * Parameters:
     * * `#`               **mode**  -
     * * `tonNode.blockId` **id**    -
     * * `long`            **lt**    - Optional:
     * * `int`             **utime** - Optional:.
     *
     * @param array $params Parameters
     * @return liteServer.BlockHeader
     */
    public function lookupBlock(array $params): liteServer;

    /**
     * Parameters:
     * * `tonNode.blockIdExt`        **id**            -
     * * `#`                         **mode**          -
     * * `#`                         **count**         -
     * * `liteServer.transactionId3` **after**         - Optional:
     * * `boolean`                   **reverse_order** - Optional:
     * * `boolean`                   **want_proof**    - Optional:.
     *
     * @param array $params Parameters
     * @return liteServer.BlockTransactions
     */
    public function listBlockTransactions(array $params): liteServer;

    /**
     * Parameters:
     * * `#`                  **mode**         -
     * * `tonNode.blockIdExt` **known_block**  -
     * * `tonNode.blockIdExt` **target_block** - Optional:.
     *
     * @param array $params Parameters
     * @return liteServer.PartialBlockProof
     */
    public function getBlockProof(array $params): liteServer;

    /**
     * Parameters:
     * * `#`                  **mode** -
     * * `tonNode.blockIdExt` **id**   -.
     *
     * @param array $params Parameters
     * @return liteServer.ConfigInfo
     */
    public function getConfigAll(array $params): liteServer;

    /**
     * Parameters:
     * * `#`                  **mode**       -
     * * `tonNode.blockIdExt` **id**         -
     * * `[int]`              **param_list** -.
     *
     * @param array $params Parameters
     * @return liteServer.ConfigInfo
     */
    public function getConfigParams(array $params): liteServer;

    /**
     * Parameters:
     * * `#`                  **mode**           -
     * * `tonNode.blockIdExt` **id**             -
     * * `int`                **limit**          -
     * * `int256`             **start_after**    - Optional:
     * * `int`                **modified_after** - Optional:.
     *
     * @param array $params Parameters
     * @return liteServer.ValidatorStats
     */
    public function getValidatorStats(array $params): liteServer;

    public function queryPrefix(): object;

    /**
     * Parameters:
     * * `bytes` **data** -.
     *
     * @param array $params Parameters
     */
    public function query(array $params): object;

    /**
     * Parameters:
     * * `int` **seqno**      -
     * * `int` **timeout_ms** -.
     *
     * @param array $params Parameters
     */
    public function waitMasterchainSeqno(array $params): object;
}

interface tcp
{
    /**
     * @return tcp.Pong
     */
    public function ping(): tcp;
}

interface dht
{
    /**
     * @return dht.Pong
     */
    public function ping(): dht;

    /**
     * Parameters:
     * * `dht.value` **value** -.
     *
     * @param array $params Parameters
     * @return dht.Stored
     */
    public function store(array $params): dht;

    /**
     * Parameters:
     * * `int256` **key** -
     * * `int`    **k**   -.
     *
     * @param array $params Parameters
     * @return dht.Nodes
     */
    public function findNode(array $params): dht;

    /**
     * Parameters:
     * * `int256` **key** -
     * * `int`    **k**   -.
     *
     * @param array $params Parameters
     * @return dht.ValueResult
     */
    public function findValue(array $params): dht;

    /**
     * @return dht.Node
     */
    public function getSignedAddressList(): dht;

    /**
     * Parameters:
     * * `dht.node` **node** -.
     *
     * @param array $params Parameters
     * @return true
     */
    public function query(array $params): bool;
}

interface overlay
{
    /**
     * Parameters:
     * * `overlay.nodes` **peers** -.
     *
     * @param array $params Parameters
     * @return overlay.Nodes
     */
    public function getRandomPeers(array $params): overlay;

    /**
     * Parameters:
     * * `int256` **overlay** -.
     *
     * @param array $params Parameters
     * @return true
     */
    public function query(array $params): bool;

    /**
     * Parameters:
     * * `int256` **hash** -.
     *
     * @param array $params Parameters
     * @return overlay.Broadcast
     */
    public function getBroadcast(array $params): overlay;

    /**
     * Parameters:
     * * `overlay.broadcastList` **list** -.
     *
     * @param array $params Parameters
     * @return overlay.BroadcastList
     */
    public function getBroadcastList(array $params): overlay;
}

interface catchain
{
    /**
     * Parameters:
     * * `int256` **block** -.
     *
     * @param array $params Parameters
     * @return catchain.BlockResult
     */
    public function getBlock(array $params): catchain;

    /**
     * Parameters:
     * * `[int256]` **blocks** -.
     *
     * @param array $params Parameters
     * @return catchain.Sent
     */
    public function getBlocks(array $params): catchain;

    /**
     * Parameters:
     * * `[int]` **rt** -.
     *
     * @param array $params Parameters
     * @return catchain.Difference
     */
    public function getDifference(array $params): catchain;

    /**
     * Parameters:
     * * `int256`   **block**   -
     * * `long`     **height**  -
     * * `[int256]` **stop_if** -.
     *
     * @param array $params Parameters
     * @return catchain.Sent
     */
    public function getBlockHistory(array $params): catchain;
}

interface validatorSession
{
    /**
     * Parameters:
     * * `long` **hash** -.
     *
     * @param array $params Parameters
     * @return validatorSession.Pong
     */
    public function ping(array $params): validatorSession;

    /**
     * Parameters:
     * * `int`                          **round** -
     * * `validatorSession.candidateId` **id**    -.
     *
     * @param array $params Parameters
     * @return validatorSession.Candidate
     */
    public function downloadCandidate(array $params): validatorSession;
}

interface tonNode
{
    /**
     * Parameters:
     * * `tonNode.blockIdExt` **prev_block** -.
     *
     * @param array $params Parameters
     * @return tonNode.BlockDescription
     */
    public function getNextBlockDescription(array $params): tonNode;

    /**
     * Parameters:
     * * `tonNode.blockIdExt` **prev_block** -
     * * `int`                **limit**      -.
     *
     * @param array $params Parameters
     * @return tonNode.BlocksDescription
     */
    public function getNextBlocksDescription(array $params): tonNode;

    /**
     * Parameters:
     * * `tonNode.blockIdExt` **next_block**   -
     * * `int`                **limit**        -
     * * `int`                **cutoff_seqno** -.
     *
     * @param array $params Parameters
     * @return tonNode.BlocksDescription
     */
    public function getPrevBlocksDescription(array $params): tonNode;

    /**
     * Parameters:
     * * `tonNode.blockIdExt` **block**         -
     * * `Bool`               **allow_partial** -.
     *
     * @param array $params Parameters
     * @return tonNode.PreparedProof
     */
    public function prepareBlockProof(array $params): tonNode;

    /**
     * Parameters:
     * * `[tonNode.blockIdExt]` **blocks**        -
     * * `Bool`                 **allow_partial** -.
     *
     * @param array $params Parameters
     * @return tonNode.PreparedProof
     */
    public function prepareBlockProofs(array $params): tonNode;

    /**
     * Parameters:
     * * `tonNode.blockIdExt` **block** -.
     *
     * @param array $params Parameters
     * @return tonNode.Prepared
     */
    public function prepareBlock(array $params): tonNode;

    /**
     * Parameters:
     * * `[tonNode.blockIdExt]` **blocks** -.
     *
     * @param array $params Parameters
     * @return tonNode.Prepared
     */
    public function prepareBlocks(array $params): tonNode;

    /**
     * Parameters:
     * * `tonNode.blockIdExt` **block**             -
     * * `tonNode.blockIdExt` **masterchain_block** -.
     *
     * @param array $params Parameters
     * @return tonNode.PreparedState
     */
    public function preparePersistentState(array $params): tonNode;

    /**
     * Parameters:
     * * `tonNode.blockIdExt` **block** -.
     *
     * @param array $params Parameters
     * @return tonNode.PreparedState
     */
    public function prepareZeroState(array $params): tonNode;

    /**
     * Parameters:
     * * `tonNode.blockIdExt` **block**    -
     * * `int`                **max_size** -.
     *
     * @param array $params Parameters
     * @return tonNode.KeyBlocks
     */
    public function getNextKeyBlockIds(array $params): tonNode;

    /**
     * Parameters:
     * * `tonNode.blockIdExt` **prev_block** -.
     *
     * @param array $params Parameters
     * @return tonNode.DataFull
     */
    public function downloadNextBlockFull(array $params): tonNode;

    /**
     * Parameters:
     * * `tonNode.blockIdExt` **block** -.
     *
     * @param array $params Parameters
     * @return tonNode.DataFull
     */
    public function downloadBlockFull(array $params): tonNode;

    /**
     * Parameters:
     * * `tonNode.blockIdExt` **block** -.
     *
     * @param array $params Parameters
     * @return tonNode.Data
     */
    public function downloadBlock(array $params): tonNode;

    /**
     * Parameters:
     * * `[tonNode.blockIdExt]` **blocks** -.
     *
     * @param array $params Parameters
     * @return tonNode.DataList
     */
    public function downloadBlocks(array $params): tonNode;

    /**
     * Parameters:
     * * `tonNode.blockIdExt` **block**             -
     * * `tonNode.blockIdExt` **masterchain_block** -.
     *
     * @param array $params Parameters
     * @return tonNode.Data
     */
    public function downloadPersistentState(array $params): tonNode;

    /**
     * Parameters:
     * * `tonNode.blockIdExt` **block**             -
     * * `tonNode.blockIdExt` **masterchain_block** -
     * * `long`               **offset**            -
     * * `long`               **max_size**          -.
     *
     * @param array $params Parameters
     * @return tonNode.Data
     */
    public function downloadPersistentStateSlice(array $params): tonNode;

    /**
     * Parameters:
     * * `tonNode.blockIdExt` **block** -.
     *
     * @param array $params Parameters
     * @return tonNode.Data
     */
    public function downloadZeroState(array $params): tonNode;

    /**
     * Parameters:
     * * `tonNode.blockIdExt` **block** -.
     *
     * @param array $params Parameters
     * @return tonNode.Data
     */
    public function downloadBlockProof(array $params): tonNode;

    /**
     * Parameters:
     * * `[tonNode.blockIdExt]` **blocks** -.
     *
     * @param array $params Parameters
     * @return tonNode.DataList
     */
    public function downloadBlockProofs(array $params): tonNode;

    /**
     * Parameters:
     * * `tonNode.blockIdExt` **block** -.
     *
     * @param array $params Parameters
     * @return tonNode.Data
     */
    public function downloadBlockProofLink(array $params): tonNode;

    /**
     * Parameters:
     * * `[tonNode.blockIdExt]` **blocks** -.
     *
     * @param array $params Parameters
     * @return tonNode.DataList
     */
    public function downloadBlockProofLinks(array $params): tonNode;

    /**
     * Parameters:
     * * `int` **masterchain_seqno** -.
     *
     * @param array $params Parameters
     * @return tonNode.ArchiveInfo
     */
    public function getArchiveInfo(array $params): tonNode;

    /**
     * Parameters:
     * * `long` **archive_id** -
     * * `long` **offset**     -
     * * `int`  **max_size**   -.
     *
     * @param array $params Parameters
     * @return tonNode.Data
     */
    public function getArchiveSlice(array $params): tonNode;

    /**
     * @return tonNode.Capabilities
     */
    public function getCapabilities(): tonNode;

    /**
     * Parameters:
     * * `tonNode.externalMessage` **message** -.
     *
     * @param array $params Parameters
     * @return tonNode.Success
     */
    public function slave(array $params): tonNode;

    public function query(): object;
}

interface adnl
{
    /**
     * Parameters:
     * * `long` **value** -.
     *
     * @param array $params Parameters
     * @return adnl.Pong
     */
    public function ping(array $params): adnl;
}

interface engine
{
    /**
     * Parameters:
     * * `PrivateKey` **key**                 -
     * * `int256`     **key_hash**            -
     * * `int`        **category**            -
     * * `int`        **election_date**       -
     * * `int`        **ttl**                 -
     * * `int256`     **permanent_key_hash**  -
     * * `int256`     **adnl_id**             -
     * * `int`        **port**                -
     * * `int256`     **peer_key**            -
     * * `int`        **permissions**         -
     * * `int`        **ip**                  -
     * * `[int]`      **categories**          -
     * * `[int]`      **priority_categories** -
     * * `int`        **in_ip**               -
     * * `int`        **in_port**             -
     * * `int`        **out_ip**              -
     * * `int`        **out_port**            -
     * * `adnl.Proxy` **proxy**               -
     * * `bytes`      **data**                -
     * * `int`        **verbosity**           -
     * * `string`     **election_addr**       -
     * * `string`     **wallet**              -
     * * `int256`     **id**                  -.
     *
     * @param array $params Parameters
     */
    public function validator(array $params): object;
}

interface http
{
    /**
     * Parameters:
     * * `int256`        **id**           -
     * * `string`        **method**       -
     * * `string`        **url**          -
     * * `string`        **http_version** -
     * * `[http.header]` **headers**      -.
     *
     * @param array $params Parameters
     * @return http.Response
     */
    public function request(array $params): http;

    /**
     * Parameters:
     * * `int256` **id**             -
     * * `int`    **seqno**          -
     * * `int`    **max_chunk_size** -.
     *
     * @param array $params Parameters
     * @return http.PayloadPart
     */
    public function getNextPayloadPart(array $params): http;
}

class InternalDoc extends APIFactory
{
    /**
         * Call promise $b after promise $a.
         *
         * @param Generator|Promise $a Promise A
         * @param Generator|Promise $b Promise B
     * @psalm-suppress InvalidScope
     */
    public function after($a, $b): Future
    {
        return Tools::after($a, $b);
    }
    /**
     * Returns a promise that succeeds when all promises succeed, and fails if any promise fails.
     * Returned promise succeeds with an array of values used to succeed each contained promise, with keys corresponding to the array of promises.
     *
     * @param array<(Generator|Promise)> $promises Promises
     */
    public function all(array $promises): Future
    {
        return Tools::all($promises);
    }
    /**
     * Returns a promise that is resolved when all promises are resolved. The returned promise will not fail.
     *
     * @param array<(Promise|Generator)> $promises Promises
     */
    public function any(array $promises): Future
    {
        return Tools::any($promises);
    }
    /**
     * Create array.
     *
     * @param mixed ...$params Params
     */
    public function arr(...$params): array
    {
        return Tools::arr(...$params);
    }
    /**
     * base64URL decode.
     *
     * @param string $data Data to decode
     */
    public function base64urlDecode(string $data): string
    {
        return Tools::base64urlDecode($data);
    }
    /**
     * Base64URL encode.
     *
     * @param string $data Data to encode
     */
    public function base64urlEncode(string $data): string
    {
        return Tools::base64urlEncode($data);
    }
    /**
     * Convert parameters.
     *
     * @param array $parameters Parameters
     */
    public function botAPItoMTProto(array $parameters, array $extra = []): Future
    {
        return $this->__call(__FUNCTION__, [$parameters, $extra]);
    }
    /**
     * Convert generator, promise or any other value to a promise.
     *
     * @param Generator|Promise|mixed $promise
     * @template TReturn
     * @psalm-param Generator<mixed, mixed, mixed, TReturn>|Promise<TReturn>|TReturn $promise
     * @psalm-return Promise<TReturn>
     */
    public function call($promise): Future
    {
        return Tools::call($promise);
    }
    /**
     * Call promise in background.
     *
     * @param Generator|Promise $promise Promise to resolve
     * @param ?\Generator|Promise $actual  Promise to resolve instead of $promise
     * @param string              $file    File
     * @psalm-suppress InvalidScope
     * @return Promise|mixed
     */
    public function callFork($promise, $actual = null, string $file = '')
    {
        return Tools::callFork($promise, $actual, $file);
    }
    /**
     * Call promise in background, deferring execution.
     *
     * @param Generator|Promise $promise Promise to resolve
     */
    public function callForkDefer($promise): void
    {
        Tools::callForkDefer($promise);
    }
    /**
     * Close connection with client, connected via web.
     *
     * @param string $message Message
     * @return void
     */
    public function closeConnection(string $message)
    {
        return Tools::closeConnection($message);
    }
    /**
     * Connect to the lite endpoints specified in the config file.
     *
     * @param string $config Path to config file
     */
    public function connect(string $config, array $extra = []): Future
    {
        return $this->__call(__FUNCTION__, [$config, $extra]);
    }
    /**
     * Asynchronously write to stdout/browser.
     *
     * @param string $string Message to echo
     */
    public function echo(string $string): Future
    {
        return Tools::echo($string);
    }
    /**
     * Get final element of array.
     *
     * @param array $what Array
     */
    public function end(array $what)
    {
        return Tools::end($what);
    }
    /**
     * Returns a promise that succeeds when the first promise succeeds, and fails only if all promises fail.
     *
     * @param array<(Promise|Generator)> $promises Promises
     */
    public function first(array $promises): Future
    {
        return Tools::first($promises);
    }
    /**
     * Asynchronously lock a file
     * Resolves with a callbable that MUST eventually be called in order to release the lock.
     *
     * @param string    $file      File to lock
     * @param integer   $operation Locking mode
     * @param float     $polling   Polling interval
     * @param ?Promise  $token     Cancellation token
     * @param ?callable $failureCb Failure callback, called only once if the first locking attempt fails.
     * @return \Amp\Future<$token is null ? callable : ?callable>
     */
    public function flock(string $file, int $operation, float $polling = 0.1, ?Promise $token = null, ?callable $failureCb = null)
    {
        return Tools::flock($file, $operation, $polling, $token, $failureCb);
    }
    /**
     * Generate MTProto vector hash.
     *
     * @param array $ints IDs
     * @return string Vector hash
     */
    public function genVectorHash(array $ints): string
    {
        return Tools::genVectorHash($ints);
    }
    /**
     * Get extension from file location.
     *
     * @param mixed  $location File location
     * @param string $default  Default extension
     */
    public function getExtensionFromLocation($location, string $default): string
    {
        return Extension::getExtensionFromLocation($location, $default);
    }
    /**
     * Get extension from mime type.
     *
     * @param string $mime MIME type
     */
    public function getExtensionFromMime(string $mime): string
    {
        return Extension::getExtensionFromMime($mime);
    }
    /**
     * Get TL method namespaces.
     *
     * @psalm-return array|Promise<array>
     */
    public function getMethodNamespaces()
    {
        return $this->__call(__FUNCTION__, []);
    }
    /**
     * Get mime type from buffer.
     *
     * @param string $buffer Buffer
     */
    public function getMimeFromBuffer(string $buffer): string
    {
        return Extension::getMimeFromBuffer($buffer);
    }
    /**
     * Get mime type from file extension.
     *
     * @param string $extension File extension
     * @param string $default   Default mime type
     */
    public function getMimeFromExtension(string $extension, string $default): string
    {
        return Extension::getMimeFromExtension($extension, $default);
    }
    /**
     * Get mime type of file.
     *
     * @param string $file File
     */
    public function getMimeFromFile(string $file): string
    {
        return Extension::getMimeFromFile($file);
    }
    /**
     * Accesses a private variable from an object.
     *
     * @param object $obj Object
     * @param string $var Attribute name
     * @psalm-suppress InvalidScope
     * @access public
     */
    public function getVar(object $obj, string $var)
    {
        return Tools::getVar($obj, $var);
    }
    /**
     * Checks private property exists in an object.
     *
     * @param object $obj Object
     * @param string $var Attribute name
     * @psalm-suppress InvalidScope
     * @access public
     */
    public function hasVar(object $obj, string $var): bool
    {
        return Tools::hasVar($obj, $var);
    }
    /**
     * Inflate stripped photosize to full JPG payload.
     *
     * @param string $stripped Stripped photosize
     * @return string JPG payload
     */
    public function inflateStripped(string $stripped): string
    {
        return Tools::inflateStripped($stripped);
    }
    /**
     * Whether this is altervista.
     */
    public function isAltervista(): bool
    {
        return Tools::isAltervista();
    }
    /**
     * Check if is array or similar (traversable && countable && arrayAccess).
     *
     * @param mixed $var Value to check
     */
    public function isArrayOrAlike($var): bool
    {
        return Tools::isArrayOrAlike($var);
    }
    /**
     * Logger.
     *
     * @param string $param Parameter
     * @param int    $level Logging level
     * @param string $file  File where the message originated
     * @psalm-return void|Promise<void>
     */
    public function logger(string $param, int $level = Logger::NOTICE, string $file = ''): void
    {
        $this->__call(__FUNCTION__, [$param, $level, $file]);
    }
    /**
     * Asynchronously run async callable.
     *
     * @param callable $func Function
     */
    public function loop(callable $func, array $extra = []): Future
    {
        return $this->__call(__FUNCTION__, [$func, $extra]);
    }
    /**
     * Escape string for markdown.
     *
     * @param string $hwat String to escape
     */
    public function markdownEscape(string $hwat): string
    {
        return StrTools::markdownEscape($hwat);
    }
    /**
     * Call lite method.
     *
     * @param string $methodName Method name
     * @param array  $args       Arguments
     */
    public function methodCall(string $methodName, array $args = [
    ], array $aargs = [
    ], array $extra = []): Future
    {
        return $this->__call(__FUNCTION__, [$methodName, $args, $aargs, $extra]);
    }
    /**
     * Escape method name.
     *
     * @param string $method Method name
     */
    public function methodEscape(string $method): string
    {
        return StrTools::methodEscape($method);
    }
    /**
     * Convert double to binary version.
     *
     * @param float $value Value to convert
     */
    public function packDouble(float $value): string
    {
        return Tools::packDouble($value);
    }
    /**
     * Convert integer to base256 signed int.
     *
     * @param integer $value Value to convert
     */
    public function packSignedInt(int $value): string
    {
        return Tools::packSignedInt($value);
    }
    /**
     * Convert integer to base256 long.
     *
     * @param int $value Value to convert
     */
    public function packSignedLong(int $value): string
    {
        return Tools::packSignedLong($value);
    }
    /**
     * Convert value to unsigned base256 int.
     *
     * @param int $value Value
     */
    public function packUnsignedInt(int $value): string
    {
        return Tools::packUnsignedInt($value);
    }
    /**
     * Positive modulo
     * Works just like the % (modulus) operator, only returns always a postive number.
     *
     * @param int $a A
     * @param int $b B
     * @return int Modulo
     */
    public function posmod(int $a, int $b): int
    {
        return Tools::posmod($a, $b);
    }
    /**
     * Get random string of specified length.
     *
     * @param integer $length Length
     * @return string Random string
     */
    public function random(int $length): string
    {
        return Tools::random($length);
    }
    /**
     * Get random integer.
     *
     * @param integer $modulus Modulus
     */
    public function randomInt(int $modulus = 0): int
    {
        return Tools::randomInt($modulus);
    }
    /**
     * Asynchronously read line.
     *
     * @param string $prompt Prompt
     * @return Promise<string>
     */
    public function readLine(string $prompt = ''): Future
    {
        return Tools::readLine($prompt);
    }
    /**
     * Rethrow error catched in strand.
     *
     * @param Throwable $e Exception
     * @param string     $file File where the strand started
     * @psalm-suppress InvalidScope
     */
    public function rethrow(Throwable $e, string $file = ''): void
    {
        Tools::rethrow($e, $file);
    }
    /**
     * null-byte RLE decode.
     *
     * @param string $string Data to decode
     */
    public function rleDecode(string $string): string
    {
        return Tools::rleDecode($string);
    }
    /**
     * null-byte RLE encode.
     *
     * @param string $string Data to encode
     */
    public function rleEncode(string $string): string
    {
        return Tools::rleEncode($string);
    }
    /**
     * Sets a private variable in an object.
     *
     * @param object $obj Object
     * @param string $var Attribute name
     * @param mixed  $val Attribute value
     * @psalm-suppress InvalidScope
     * @access public
     */
    public function setVar(object $obj, string $var, &$val): void
    {
        Tools::setVar($obj, $var, $val);
    }
    /**
     * Asynchronously sleep.
     *
     * @param int|float $time Number of seconds to sleep for
     */
    public function sleep($time): Future
    {
        return Tools::sleep($time);
    }
    /**
     * Resolves with a two-item array delineating successful and failed Promise results.
     * The returned promise will only fail if the given number of required promises fail.
     *
     * @param array<(Promise|Generator)> $promises Promises
     */
    public function some(array $promises): Future
    {
        return Tools::some($promises);
    }
    /**
     * Create an artificial timeout for any \Generator or Promise.
     *
     * @param Generator|Promise $promise
     */
    public function timeout($promise, int $timeout): Future
    {
        return Tools::timeout($promise, $timeout);
    }
    /**
     * Creates an artificial timeout for any `Promise`.
     *
     * If the promise is resolved before the timeout expires, the result is returned
     *
     * If the timeout expires before the promise is resolved, a default value is returned
     *
     * @template TReturnAlt
     * @template TReturn
     * @template TGenerator of Generator<mixed, mixed, mixed, TReturn>
     * @param Promise|Generator $promise Promise to which the timeout is applied.
     * @param int               $timeout Timeout in milliseconds.
     * @psalm-param Promise<TReturn>|TGenerator $promise Promise to which the timeout is applied.
     * @psalm-param TReturnAlt $default
     * @return Promise<TReturn>|Promise<TReturnAlt>
     * @throws TypeError If $promise is not an instance of \Amp\Future, \Generator or \React\Promise\PromiseInterface.
     */
    public function timeoutWithDefault($promise, int $timeout, $default = null): Future
    {
        return Tools::timeoutWithDefault($promise, $timeout, $default);
    }
    /**
     * Convert to camelCase.
     *
     * @param string $input String
     */
    public function toCamelCase(string $input): string
    {
        return StrTools::toCamelCase($input);
    }
    /**
     * Convert to snake_case.
     *
     * @param string $input String
     */
    public function toSnakeCase(string $input): string
    {
        return StrTools::toSnakeCase($input);
    }
    /**
     * Escape type name.
     *
     * @param string $type String to escape
     */
    public function typeEscape(string $type): string
    {
        return StrTools::typeEscape($type);
    }
    /**
     * Unpack binary double.
     *
     * @param string $value Value to unpack
     */
    public function unpackDouble(string $value): float
    {
        return Tools::unpackDouble($value);
    }
    /**
     * Unpack base256 signed int.
     *
     * @param string $value base256 int
     */
    public function unpackSignedInt(string $value): int
    {
        return Tools::unpackSignedInt($value);
    }
    /**
     * Unpack base256 signed long.
     *
     * @param string $value base256 long
     */
    public function unpackSignedLong(string $value): int
    {
        return Tools::unpackSignedLong($value);
    }
    /**
     * Unpack base256 signed long to string.
     *
     * @param string|int|array $value base256 long
     */
    public function unpackSignedLongString($value): string
    {
        return Tools::unpackSignedLongString($value);
    }
    /**
     * Synchronously wait for a promise|generator.
     *
     * @param Generator|Promise $promise The promise to wait for
     * @param boolean            $ignoreSignal Whether to ignore shutdown signals
     */
    public function wait($promise, bool $ignoreSignal = false)
    {
        return Tools::wait($promise, $ignoreSignal);
    }
}
